// services/auditService.js
import apiClient from '../config/api.js';

/**
 * Funci√≥n utilitaria para obtener timestamp en hora de Costa Rica
 */
const getCostaRicaTimestamp = () => {
  const now = new Date();
  
  // Crear directamente una fecha con la hora de Costa Rica
  // Usando el offset de Costa Rica (-6 horas de UTC)
  const costaRicaOffset = -6 * 60; // -6 horas en minutos
  const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
  const costaRicaTime = new Date(utc + (costaRicaOffset * 60000));
  
  // Formatear manualmente para asegurar que sea correcto
  const year = costaRicaTime.getFullYear();
  const month = String(costaRicaTime.getMonth() + 1).padStart(2, '0');
  const day = String(costaRicaTime.getDate()).padStart(2, '0');
  const hours = String(costaRicaTime.getHours()).padStart(2, '0');
  const minutes = String(costaRicaTime.getMinutes()).padStart(2, '0');
  const seconds = String(costaRicaTime.getSeconds()).padStart(2, '0');
  const milliseconds = String(costaRicaTime.getMilliseconds()).padStart(3, '0');
  
  const costaRicaISO = `${year}-${month}-${day}T${hours}:${minutes}:${seconds}.${milliseconds}Z`;
  
  console.log('üá®üá∑ Timestamp Costa Rica generado (auditService):', {
    horaUTC: now.toISOString(),
    horaCostaRica: costaRicaISO,
    horaLegible: `${day}/${month}/${year}, ${hours}:${minutes}:${seconds}`
  });
  
  return costaRicaISO;
};

const auditService = {
  // ===== DATOS SIMULADOS PARA DEMO =====

  /**
   * Genera datos simulados para demostrar la funcionalidad cuando el backend no est√° disponible
   * 
   * Estructura esperada del backend para usuarios:
   * - name: string (255 caracteres)
   * - lastname: string (255 caracteres, nullable)
   * 
   * Los logs deben contener tanto name/lastname como campos de compatibilidad
   */
  getSimulatedAuditLogs: () => {
    const simulatedLogs = [
      {
        id: '1',
        action: 'AUTH',
        entity: 'authentication',
        entityId: null,
        userId: 'user123',
        userName: 'Juan P√©rez',
        name: 'Juan Carlos',
        lastname: 'P√©rez Gonz√°lez',
        userFullName: 'Juan Carlos P√©rez Gonz√°lez',
        userCedula: '123456789',
        description: 'Usuario inici√≥ sesi√≥n en el sistema',
        timestamp: new Date(Date.now() - 1000 * 60 * 30).toISOString(),
        changes: { before: null, after: { status: 'logged_in' } },
        metadata: { userAgent: 'Mozilla/5.0...', ip: '192.168.1.100' }
      },
      {
        id: '2',
        action: 'CREATE',
        entity: 'transporte',
        entityId: 'vehicle-001',
        userId: 'user456',
        userName: 'Mar√≠a Garc√≠a',
        name: 'Mar√≠a Elena',
        lastname: 'Garc√≠a Rodr√≠guez',
        userFullName: 'Mar√≠a Elena Garc√≠a Rodr√≠guez',
        userCedula: '987654321',
        description: 'Se cre√≥ un nuevo veh√≠culo de transporte',
        timestamp: new Date(Date.now() - 1000 * 60 * 60).toISOString(),
        changes: { 
          before: null, 
          after: { placa: 'ABC-123', tipo: 'Cami√≥n', estado: 'Activo' } 
        },
        metadata: { userAgent: 'Mozilla/5.0...', ip: '192.168.1.101' }
      },
      {
        id: '3',
        action: 'UPDATE',
        entity: 'operadores',
        entityId: 'op-789',
        userId: 'user789',
        userName: 'Carlos L√≥pez',
        name: 'Carlos Antonio',
        lastname: 'L√≥pez Vargas',
        userFullName: 'Carlos Antonio L√≥pez Vargas',
        userCedula: '456789123',
        description: 'Se actualiz√≥ informaci√≥n del operador',
        timestamp: new Date(Date.now() - 1000 * 60 * 120).toISOString(),
        changes: { 
          before: { nombre: 'Carlos Lopez', telefono: '123456789' }, 
          after: { nombre: 'Carlos L√≥pez', telefono: '987654321' } 
        },
        metadata: { userAgent: 'Mozilla/5.0...', ip: '192.168.1.102' }
      },
      {
        id: '4',
        action: 'DELETE',
        entity: 'reportes',
        entityId: 'report-456',
        userId: 'user123',
        userName: 'Juan P√©rez',
        name: 'Juan Carlos',
        lastname: 'P√©rez Gonz√°lez',
        userFullName: 'Juan Carlos P√©rez Gonz√°lez',
        userCedula: '123456789',
        description: 'Se elimin√≥ un reporte de actividades',
        timestamp: new Date(Date.now() - 1000 * 60 * 180).toISOString(),
        changes: { 
          before: { id: 'report-456', tipo: 'Mantenimiento', estado: 'Completado' }, 
          after: null 
        },
        metadata: { userAgent: 'Mozilla/5.0...', ip: '192.168.1.103' }
      },
      {
        id: '5',
        action: 'RESTORE',
        entity: 'reportes',
        entityId: 'report-789',
        userId: 'user890',
        userName: 'Ana Rodr√≠guez',
        name: 'Ana Patricia',
        lastname: 'Rodr√≠guez Morales',
        userFullName: 'Ana Patricia Rodr√≠guez Morales',
        userCedula: '789123456',
        description: 'Se restaur√≥ un reporte eliminado',
        timestamp: new Date(Date.now() - 1000 * 60 * 240).toISOString(),
        changes: { 
          before: null, 
          after: { id: 'report-789', tipo: 'Inspecci√≥n', estado: 'Pendiente' } 
        },
        metadata: { userAgent: 'Mozilla/5.0...', ip: '192.168.1.104' }
      },
      {
        id: '6',
        action: 'CREATE',
        entity: 'operadores',
        entityId: 'op-456',
        userId: 'user234',
        userName: 'Luis Ram√≠rez',
        name: 'Luis Fernando',
        lastname: 'Ram√≠rez Jim√©nez',
        userFullName: 'Luis Fernando Ram√≠rez Jim√©nez',
        userCedula: '234567890',
        description: 'Se registr√≥ un nuevo operador',
        timestamp: new Date(Date.now() - 1000 * 60 * 300).toISOString(),
        changes: { 
          before: null, 
          after: { nombre: 'Luis Fernando', licencia: 'B2', estado: 'Activo' } 
        },
        metadata: { userAgent: 'Mozilla/5.0...', ip: '192.168.1.105' }
      }
    ];

    console.log('üìã Datos simulados generados con name/lastname:', simulatedLogs.map(log => ({
      id: log.id,
      name: log.name,
      lastname: log.lastname,
      hasNames: !!(log.name && log.lastname)
    })));

    return {
      success: true,
      data: {
        logs: simulatedLogs,
        currentPage: 1,
        totalPages: 1,
        total: simulatedLogs.length,
        limit: 50
      }
    };
  },

  /**
   * Genera estad√≠sticas simuladas para demostrar la funcionalidad
   */
  getSimulatedAuditStats: () => {
    return {
      success: true,
      data: {
        totalEvents: 67,
        eventsByAction: {
          CREATE: 18,
          UPDATE: 25,
          DELETE: 9,
          AUTH: 12,
          ROLE_CHANGE: 3
        },
        eventsByEntity: {
          usuarios: 12,
          transporte: 15,
          operadores: 18,
          reportes: 14,
          roles: 3,
          authentication: 5
        },
        recentActivity: {
          last24Hours: 8,
          last7Days: 34,
          last30Days: 67
        },
        topUsers: [
          { userId: 'user123', userName: 'Juan P√©rez', eventCount: 12 },
          { userId: 'user456', userName: 'Mar√≠a Garc√≠a', eventCount: 9 },
          { userId: 'user789', userName: 'Carlos L√≥pez', eventCount: 7 }
        ]
      }
    };
  },

  // ===== REGISTRO DE EVENTOS DE AUDITOR√çA =====
  
  /**
   * Registra un evento de auditor√≠a
   * @param {Object} auditData - Datos del evento de auditor√≠a
   * @param {string} auditData.action - Tipo de acci√≥n (CREATE, UPDATE, DELETE)
   * @param {string} auditData.entity - Entidad afectada (usuarios, transporte, operadores, etc.)
   * @param {string} auditData.entityId - ID de la entidad afectada
   * @param {Object} auditData.changes - Cambios realizados (antes y despu√©s)
   * @param {string} auditData.description - Descripci√≥n del cambio
   * @param {Object} auditData.metadata - Metadatos adicionales
   */
  logEvent: async (auditData) => {
    console.log('üöÄ auditService.logEvent llamado con:', auditData);
    
    try {
      const token = localStorage.getItem('token');
      console.log('üîë Token disponible:', !!token);
      
      console.log('üì§ Enviando petici√≥n POST a /audit/log...');
      const response = await apiClient.post('/audit/log', auditData, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      console.log('‚úÖ Respuesta del backend:', response.data);
      return { success: true, data: response.data };
    } catch (error) {
      console.error('‚ùå Error logging audit event:', error);
      console.error('üìã Detalles del error:', {
        status: error.response?.status,
        message: error.response?.data?.message,
        data: error.response?.data
      });
      // No lanzamos error para que no afecte la operaci√≥n principal
      return { success: false, error: error.response?.data?.message || 'Error al registrar evento de auditor√≠a' };
    }
  },

  /**
   * Registra un evento de creaci√≥n
   */
  logCreate: async (entity, entityId, newData, description = '') => {
    return await auditService.logEvent({
      action: 'CREATE',
      entity,
      entityId: entityId?.toString(),
      changes: {
        before: null,
        after: newData
      },
      description: description || `Se cre√≥ un nuevo ${entity}`,
      metadata: {
        timestamp: getCostaRicaTimestamp(),
        userAgent: navigator.userAgent
      }
    });
  },

  /**
   * Registra un evento de actualizaci√≥n
   */
  logUpdate: async (entity, entityId, beforeData, afterData, description = '') => {
    return await auditService.logEvent({
      action: 'UPDATE',
      entity,
      entityId: entityId?.toString(),
      changes: {
        before: beforeData,
        after: afterData
      },
      description: description || `Se actualiz√≥ ${entity}`,
      metadata: {
        timestamp: getCostaRicaTimestamp(),
        userAgent: navigator.userAgent
      }
    });
  },

  /**
   * Registra un evento de eliminaci√≥n
   */
  logDelete: async (entity, entityId, deletedData, description = '') => {
    return await auditService.logEvent({
      action: 'DELETE',
      entity,
      entityId: entityId?.toString(),
      changes: {
        before: deletedData,
        after: null
      },
      description: description || `Se elimin√≥ ${entity}`,
      metadata: {
        timestamp: getCostaRicaTimestamp(),
        userAgent: navigator.userAgent
      }
    });
  },

  // ===== CONSULTA DE LOGS DE AUDITOR√çA =====

  /**
   * Obtiene todos los logs de auditor√≠a con filtros opcionales
   * @param {Object} filters - Filtros de b√∫squeda
   * @param {string} filters.startDate - Fecha de inicio (ISO string)
   * @param {string} filters.endDate - Fecha final (ISO string)
   * @param {string} filters.entity - Filtrar por entidad
   * @param {string} filters.action - Filtrar por acci√≥n
   * @param {string} filters.userId - Filtrar por usuario
   * @param {number} filters.page - P√°gina (para paginaci√≥n)
   * @param {number} filters.limit - L√≠mite de resultados por p√°gina
   */
  getAuditLogs: async (filters = {}) => {
    try {
      const token = localStorage.getItem('token');
      
      // Filtrar par√°metros vac√≠os para evitar errores de validaci√≥n del backend
      const cleanFilters = {};
      Object.entries(filters).forEach(([key, value]) => {
        // Siempre incluir page y limit para paginaci√≥n
        if (key === 'page' || key === 'limit') {
          cleanFilters[key] = value || (key === 'page' ? 1 : 50);
          return;
        }
        
        // Para otros filtros, validar que tengan contenido significativo
        if (value !== '' && value !== null && value !== undefined) {
          const stringValue = String(value).trim();
          if (stringValue !== '' && stringValue !== 'all') {
            // Para fechas, agregar validaci√≥n adicional
            if (key === 'startDate' || key === 'endDate') {
              const dateValue = new Date(stringValue);
              if (!isNaN(dateValue.getTime())) {
                cleanFilters[key] = stringValue;
                console.log(`‚úÖ Fecha ${key} v√°lida:`, {
                  value: stringValue,
                  parsed: dateValue.toISOString(),
                  readable: dateValue.toLocaleString('es-CR')
                });
              } else {
                console.warn(`‚ùå Fecha ${key} inv√°lida:`, stringValue);
              }
            } else {
              cleanFilters[key] = stringValue;
            }
          }
        }
      });
      
      // Logs de debug detallados
      console.log('üîç AuditService - Filtros procesados:', {
        original: filters,
        cleaned: cleanFilters,
        params: new URLSearchParams(cleanFilters).toString(),
        url: `/audit/logs?${new URLSearchParams(cleanFilters).toString()}`
      });
      
      const response = await apiClient.get('/audit/logs', {
        params: cleanFilters,
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      console.log('üéØ Respuesta del backend recibida:', {
        data: response.data,
        logs: response.data.data || response.data.logs || [],
        firstLog: (response.data.data || response.data.logs || [])[0]
      });
      return { success: true, data: response.data };
    } catch (error) {
      console.error('Error fetching audit logs:', error);
      
      // Detectar si es un error de conexi√≥n (backend no disponible)
      if (error.code === 'ERR_NETWORK' || error.message === 'Network Error') {
        console.warn('üö® Backend no disponible. Mostrando datos simulados para demostraci√≥n.');
        const simulatedData = auditService.getSimulatedAuditLogs();
        console.log('üìä Datos simulados generados:', simulatedData);
        return simulatedData;
      }
      
      throw new Error(error.response?.data?.message || 'Error al obtener logs de auditor√≠a');
    }
  },

  /**
   * Obtiene estad√≠sticas de auditor√≠a
   */
  getAuditStats: async (dateRange = {}) => {
    try {
      const token = localStorage.getItem('token');
      
      // Filtrar par√°metros vac√≠os para evitar errores de validaci√≥n del backend
      const cleanFilters = {};
      Object.entries(dateRange).forEach(([key, value]) => {
        // Solo incluir valores que no sean vac√≠os, null, undefined o cadenas vac√≠as
        if (value !== '' && value !== null && value !== undefined && String(value).trim() !== '') {
          cleanFilters[key] = value;
        }
      });

      
      const response = await apiClient.get('/audit/stats', {
        params: cleanFilters,
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      return { success: true, data: response.data };
    } catch (error) {
      console.error('Error fetching audit stats:', error);
      
      // Detectar si es un error de conexi√≥n (backend no disponible)
      if (error.code === 'ERR_NETWORK' || error.message === 'Network Error') {
        console.warn('üö® Backend no disponible. Mostrando estad√≠sticas simuladas para demostraci√≥n.');
        // Retornar estad√≠sticas simuladas
        return auditService.getSimulatedAuditStats();
      }
      
      throw new Error(error.response?.data?.message || 'Error al obtener estad√≠sticas de auditor√≠a');
    }
  },

  /**
   * Obtiene logs de auditor√≠a por entidad espec√≠fica
   */
  getAuditLogsByEntity: async (entity, entityId, limit = 50) => {
    try {
      const token = localStorage.getItem('token');
      const response = await apiClient.get(`/audit/logs/entity/${entity}/${entityId}`, {
        params: { limit },
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      return { success: true, data: response.data };
    } catch (error) {
      console.error('Error fetching entity audit logs:', error);
      throw new Error(error.response?.data?.message || 'Error al obtener logs de la entidad');
    }
  },

  /**
   * Obtiene logs de auditor√≠a por usuario
   */
  getAuditLogsByUser: async (userId, limit = 50) => {
    try {
      const token = localStorage.getItem('token');
      const response = await apiClient.get(`/audit/logs/user/${userId}`, {
        params: { limit },
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      return { success: true, data: response.data };
    } catch (error) {
      console.error('Error fetching user audit logs:', error);
      throw new Error(error.response?.data?.message || 'Error al obtener logs del usuario');
    }
  },

  /**
   * Exporta logs de auditor√≠a a CSV
   */
  exportAuditLogs: async (filters = {}) => {
    try {
      const token = localStorage.getItem('token');
      
      // Filtrar par√°metros vac√≠os para evitar errores de validaci√≥n del backend
      const cleanFilters = {};
      Object.entries(filters).forEach(([key, value]) => {
        // Solo incluir valores que no sean vac√≠os, null, undefined o cadenas vac√≠as
        if (value !== '' && value !== null && value !== undefined && String(value).trim() !== '') {
          cleanFilters[key] = value;
        }
      });

      
      const response = await apiClient.get('/audit/export', {
        params: { ...cleanFilters, format: 'csv' },
        headers: {
          'Authorization': `Bearer ${token}`
        },
        responseType: 'blob'
      });
      
      // Crear y descargar el archivo
      const blob = new Blob([response.data], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `audit-logs-${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
      
      return { success: true };
    } catch (error) {
      console.error('Error exporting audit logs:', error);
      throw new Error(error.response?.data?.message || 'Error al exportar logs de auditor√≠a');
    }
  },

  // ===== FUNCIONES DE UTILIDAD =====

  /**
   * Formatea la descripci√≥n de un cambio
   */
  formatChangeDescription: (action, entity, entityName = '') => {
    const actions = {
      CREATE: 'cre√≥',
      UPDATE: 'actualiz√≥',
      DELETE: 'elimin√≥',
      RESTORE: 'restaur√≥'
    };
    
    const entities = {
      usuarios: 'usuario',
      transporte: 'veh√≠culo',
      operadores: 'operador',
      reportes: 'reporte',
      roles: 'rol',
      solicitudes: 'solicitud'
    };
    
    const actionText = actions[action] || action.toLowerCase();
    const entityText = entities[entity] || entity;
    const nameText = entityName ? ` "${entityName}"` : '';
    
    return `Se ${actionText} el ${entityText}${nameText}`;
  },

  /**
   * Obtiene el color de la acci√≥n para la UI
   */
  getActionColor: (action) => {
    const colors = {
      CREATE: 'text-green-600 bg-green-50',
      UPDATE: 'text-blue-600 bg-blue-50',
      DELETE: 'text-red-600 bg-red-50',
      RESTORE: 'text-yellow-600 bg-yellow-50'
    };
    return colors[action] || 'text-gray-600 bg-gray-50';
  },

  /**
   * Obtiene el √≠cono de la acci√≥n
   */
  getActionIcon: (action) => {
    const icons = {
      CREATE: 'plus-circle',
      UPDATE: 'edit-3',
      DELETE: 'trash-2',
      RESTORE: 'refresh-cw'
    };
    return icons[action] || 'activity';
  },

  /**
   * Verifica si el usuario actual es superadmin
   */
  isSuperAdmin: () => {
    try {
      const userStr = localStorage.getItem('user');
      if (!userStr) return false;
      
      const user = JSON.parse(userStr);
      return user.roles && user.roles.includes('superadmin');
    } catch (error) {
      console.error('Error checking superadmin status:', error);
      return false;
    }
  },

  /**
   * Obtiene informaci√≥n de cambios detallada
   */
  getChangeDetails: (changes) => {
    if (!changes) return null;
    
    const { before, after } = changes;
    const details = [];
    
    if (!before && after) {
      // Creaci√≥n
      Object.keys(after).forEach(key => {
        if (after[key] !== null && after[key] !== undefined) {
          details.push({
            field: key,
            type: 'created',
            value: after[key]
          });
        }
      });
    } else if (before && !after) {
      // Eliminaci√≥n
      Object.keys(before).forEach(key => {
        if (before[key] !== null && before[key] !== undefined) {
          details.push({
            field: key,
            type: 'deleted',
            value: before[key]
          });
        }
      });
    } else if (before && after) {
      // Actualizaci√≥n
      const allKeys = new Set([...Object.keys(before), ...Object.keys(after)]);
      allKeys.forEach(key => {
        if (before[key] !== after[key]) {
          details.push({
            field: key,
            type: 'updated',
            oldValue: before[key],
            newValue: after[key]
          });
        }
      });
    }
    
    return details;
  }
};

export default auditService;